{
  "version": 3,
  "sources": ["../../../../../src/functions/hello/handler.ts", "../../../../../src/libs/api-gateway.ts", "../../../../../node_modules/@middy/core/index.js", "../../../../../node_modules/@middy/util/index.js", "../../../../../node_modules/@middy/http-json-body-parser/index.js", "../../../../../src/libs/lambda.ts"],
  "sourcesContent": ["import type { ValidatedEventAPIGatewayProxyEvent } from '@libs/api-gateway';\nimport { SuccessJSONResponse } from '@libs/api-gateway';\nimport { middyfy } from '@libs/lambda';\n\nimport schema from './schema';\n\nconst hello: ValidatedEventAPIGatewayProxyEvent<typeof schema> = async (\n  event\n) => {\n  return SuccessJSONResponse({\n    message: `Hello ${event.body.name}, welcome to the exciting Serverless world!`,\n    event,\n  });\n};\n\nexport const main = middyfy(hello);\n", "import type {\n  APIGatewayProxyEvent,\n  APIGatewayProxyResult,\n  Handler,\n} from 'aws-lambda';\nimport type { FromSchema } from 'json-schema-to-ts';\n\ntype ValidatedAPIGatewayProxyEvent<S> = Omit<APIGatewayProxyEvent, 'body'> & {\n  body: FromSchema<S>;\n};\nexport type ValidatedEventAPIGatewayProxyEvent<S> = Handler<\n  ValidatedAPIGatewayProxyEvent<S>,\n  APIGatewayProxyResult\n>;\n\nexport const SuccessJSONResponse = (response: Record<string, unknown>) => {\n  return {\n    statusCode: 200,\n    body: JSON.stringify(response),\n  };\n};\n\nexport const FailureJSONResponse = (response: Record<string, unknown>) => {\n  return {\n    statusCode: 400,\n    body: JSON.stringify(response),\n  };\n};\n", "import { EventEmitter } from 'events';\nconst defaultLambdaHandler = ()=>{};\nconst defaultPlugin = {\n    timeoutEarlyInMillis: 5,\n    timeoutEarlyResponse: ()=>{\n        throw new Error('Timeout');\n    }\n};\nconst middy = (lambdaHandler = defaultLambdaHandler, plugin = {})=>{\n    if (typeof lambdaHandler !== 'function') {\n        plugin = lambdaHandler;\n        lambdaHandler = defaultLambdaHandler;\n    }\n    plugin = {\n        ...defaultPlugin,\n        ...plugin\n    };\n    plugin.timeoutEarly = plugin.timeoutEarlyInMillis > 0;\n    plugin.beforePrefetch?.();\n    const beforeMiddlewares = [];\n    const afterMiddlewares = [];\n    const onErrorMiddlewares = [];\n    const middy = (event = {}, context = {})=>{\n        plugin.requestStart?.();\n        const request = {\n            event,\n            context,\n            response: undefined,\n            error: undefined,\n            internal: plugin.internal ?? {}\n        };\n        return runRequest(request, [\n            ...beforeMiddlewares\n        ], lambdaHandler, [\n            ...afterMiddlewares\n        ], [\n            ...onErrorMiddlewares\n        ], plugin);\n    };\n    middy.use = (middlewares)=>{\n        if (!Array.isArray(middlewares)) {\n            middlewares = [\n                middlewares\n            ];\n        }\n        for (const middleware of middlewares){\n            const { before , after , onError  } = middleware;\n            if (!before && !after && !onError) {\n                throw new Error('Middleware must be an object containing at least one key among \"before\", \"after\", \"onError\"');\n            }\n            if (before) middy.before(before);\n            if (after) middy.after(after);\n            if (onError) middy.onError(onError);\n        }\n        return middy;\n    };\n    middy.before = (beforeMiddleware)=>{\n        beforeMiddlewares.push(beforeMiddleware);\n        return middy;\n    };\n    middy.after = (afterMiddleware)=>{\n        afterMiddlewares.unshift(afterMiddleware);\n        return middy;\n    };\n    middy.onError = (onErrorMiddleware)=>{\n        onErrorMiddlewares.unshift(onErrorMiddleware);\n        return middy;\n    };\n    middy.handler = (replaceLambdaHandler)=>{\n        lambdaHandler = replaceLambdaHandler;\n        return middy;\n    };\n    return middy;\n};\nconst runRequest = async (request, beforeMiddlewares, lambdaHandler, afterMiddlewares, onErrorMiddlewares, plugin)=>{\n    const timeoutEarly = plugin.timeoutEarly && request.context.getRemainingTimeInMillis;\n    try {\n        await runMiddlewares(request, beforeMiddlewares, plugin);\n        if (typeof request.response === 'undefined') {\n            plugin.beforeHandler?.();\n            const handlerAbort = new AbortController();\n            let timeoutAbort;\n            if (timeoutEarly) timeoutAbort = new AbortController();\n            request.response = await Promise.race([\n                lambdaHandler(request.event, request.context, {\n                    signal: handlerAbort.signal\n                }),\n                timeoutEarly ? setTimeoutPromise(request.context.getRemainingTimeInMillis() - plugin.timeoutEarlyInMillis, {\n                    signal: timeoutAbort.signal\n                }).then(()=>{\n                    handlerAbort.abort();\n                    return plugin.timeoutEarlyResponse();\n                }) : Promise.race([])\n            ]);\n            if (timeoutEarly) timeoutAbort.abort();\n            plugin.afterHandler?.();\n            await runMiddlewares(request, afterMiddlewares, plugin);\n        }\n    } catch (e1) {\n        request.response = undefined;\n        request.error = e1;\n        try {\n            await runMiddlewares(request, onErrorMiddlewares, plugin);\n        } catch (e) {\n            e.originalError = request.error;\n            request.error = e;\n            throw request.error;\n        }\n        if (typeof request.response === 'undefined') throw request.error;\n    } finally{\n        await plugin.requestEnd?.(request);\n    }\n    return request.response;\n};\nconst runMiddlewares = async (request, middlewares, plugin)=>{\n    for (const nextMiddleware of middlewares){\n        plugin.beforeMiddleware?.(nextMiddleware.name);\n        const res = await nextMiddleware(request);\n        plugin.afterMiddleware?.(nextMiddleware.name);\n        if (typeof res !== 'undefined') {\n            request.response = res;\n            return;\n        }\n    }\n};\nconst polyfillAbortController = ()=>{\n    if (process.version < 'v15.0.0') {\n        class AbortSignal {\n            toString() {\n                return '[object AbortSignal]';\n            }\n            get [Symbol.toStringTag]() {\n                return 'AbortSignal';\n            }\n            removeEventListener(name, handler) {\n                this.eventEmitter.removeListener(name, handler);\n            }\n            addEventListener(name, handler) {\n                this.eventEmitter.on(name, handler);\n            }\n            dispatchEvent(type) {\n                const event = {\n                    type,\n                    target: this\n                };\n                const handlerName = `on${type}`;\n                if (typeof this[handlerName] === 'function') this[handlerName](event);\n                this.eventEmitter.emit(type, event);\n            }\n            constructor(){\n                this.eventEmitter = new EventEmitter();\n                this.onabort = null;\n                this.aborted = false;\n            }\n        }\n        return class AbortController1 {\n            abort() {\n                if (this.signal.aborted) return;\n                this.signal.aborted = true;\n                this.signal.dispatchEvent('abort');\n            }\n            toString() {\n                return '[object AbortController]';\n            }\n            get [Symbol.toStringTag]() {\n                return 'AbortController';\n            }\n            constructor(){\n                this.signal = new AbortSignal();\n            }\n        };\n    } else {\n        return AbortController;\n    }\n};\nglobal.AbortController = polyfillAbortController();\nconst polyfillSetTimeoutPromise = ()=>{\n    return (ms, { signal  })=>{\n        if (signal.aborted) {\n            return Promise.reject(new Error('Aborted', 'AbortError'));\n        }\n        return new Promise((resolve, reject)=>{\n            const abortHandler = ()=>{\n                clearTimeout(timeout);\n                reject(new Error('Aborted', 'AbortError'));\n            };\n            const timeout = setTimeout(()=>{\n                resolve();\n                signal.removeEventListener('abort', abortHandler);\n            }, ms);\n            signal.addEventListener('abort', abortHandler);\n        });\n    };\n};\nconst setTimeoutPromise = polyfillSetTimeoutPromise();\nexport default middy;\n\n\n//# sourceMappingURL=index.js.map", "var _response;\nimport { Agent } from 'https';\nexport const awsClientDefaultOptions = {\n    httpOptions: {\n        agent: new Agent({\n            keepAlive: true,\n            secureProtocol: 'TLSv1_2_method'\n        })\n    }\n};\nexport const createPrefetchClient = (options)=>{\n    const awsClientOptions = {\n        ...awsClientDefaultOptions,\n        ...options.awsClientOptions\n    };\n    const client = new options.AwsClient(awsClientOptions);\n    if (options.awsClientCapture && options.disablePrefetch) {\n        return options.awsClientCapture(client);\n    } else if (options.awsClientCapture) {\n        console.warn('Unable to apply X-Ray outside of handler invocation scope.');\n    }\n    return client;\n};\nexport const createClient = async (options, request)=>{\n    let awsClientCredentials = {};\n    if (options.awsClientAssumeRole) {\n        if (!request) {\n            throw new Error('Request required when assuming role');\n        }\n        awsClientCredentials = await getInternal({\n            credentials: options.awsClientAssumeRole\n        }, request);\n    }\n    awsClientCredentials = {\n        ...awsClientCredentials,\n        ...options.awsClientOptions\n    };\n    return createPrefetchClient({\n        ...options,\n        awsClientOptions: awsClientCredentials\n    });\n};\nexport const canPrefetch = (options = {})=>{\n    return !options.awsClientAssumeRole && !options.disablePrefetch;\n};\nexport const getInternal = async (variables, request)=>{\n    if (!variables || !request) return {};\n    let keys = [];\n    let values = [];\n    if (variables === true) {\n        keys = values = Object.keys(request.internal);\n    } else if (typeof variables === 'string') {\n        keys = values = [\n            variables\n        ];\n    } else if (Array.isArray(variables)) {\n        keys = values = variables;\n    } else if (typeof variables === 'object') {\n        keys = Object.keys(variables);\n        values = Object.values(variables);\n    }\n    const promises = [];\n    for (const internalKey of values){\n        const pathOptionKey = internalKey.split('.');\n        const rootOptionKey = pathOptionKey.shift();\n        let valuePromise = request.internal[rootOptionKey];\n        if (!isPromise(valuePromise)) {\n            valuePromise = Promise.resolve(valuePromise);\n        }\n        promises.push(valuePromise.then((value)=>pathOptionKey.reduce((p, c)=>p?.[c], value)));\n    }\n    values = await Promise.allSettled(promises);\n    const errors = values.filter((res)=>res.status === 'rejected').map((res)=>res.reason);\n    if (errors.length) {\n        const error = new Error('Failed to resolve internal values');\n        error.cause = errors;\n        throw error;\n    }\n    return keys.reduce((obj, key, index)=>({\n            ...obj,\n            [sanitizeKey(key)]: values[index].value\n        }), {});\n};\nconst isPromise = (promise)=>typeof promise?.then === 'function';\nconst sanitizeKeyPrefixLeadingNumber = /^([0-9])/;\nconst sanitizeKeyRemoveDisallowedChar = /[^a-zA-Z0-9]+/g;\nexport const sanitizeKey = (key)=>{\n    return key.replace(sanitizeKeyPrefixLeadingNumber, '_$1').replace(sanitizeKeyRemoveDisallowedChar, '_');\n};\nconst cache = {};\nexport const processCache = (options, fetch = ()=>undefined, request)=>{\n    const { cacheExpiry , cacheKey  } = options;\n    if (cacheExpiry) {\n        const cached = getCache(cacheKey);\n        const unexpired = cached.expiry && (cacheExpiry < 0 || cached.expiry > Date.now());\n        if (unexpired && cached.modified) {\n            const value = fetch(request, cached.value);\n            cache[cacheKey] = {\n                value: {\n                    ...cached.value,\n                    ...value\n                },\n                expiry: cached.expiry\n            };\n            return cache[cacheKey];\n        }\n        if (unexpired) {\n            return {\n                ...cached,\n                cache: true\n            };\n        }\n    }\n    const value1 = fetch(request);\n    const expiry = Date.now() + cacheExpiry;\n    if (cacheExpiry) {\n        const refresh = cacheExpiry > 0 ? setInterval(()=>{\n            const value = fetch(request);\n            const expiry = Date.now() + cacheExpiry;\n            Object.assign(cache[cacheKey], {\n                value,\n                expiry\n            });\n        }, cacheExpiry) : undefined;\n        cache[cacheKey] = {\n            value: value1,\n            expiry,\n            refresh\n        };\n    }\n    return {\n        value: value1,\n        expiry\n    };\n};\nexport const getCache = (key)=>{\n    if (!cache[key]) return {};\n    return cache[key];\n};\nexport const modifyCache = (cacheKey, value)=>{\n    if (!cache[cacheKey]) return;\n    clearInterval(cache[cacheKey]?.refresh);\n    cache[cacheKey] = {\n        ...cache[cacheKey],\n        value,\n        modified: true\n    };\n};\nexport const clearCache = (keys = null)=>{\n    keys = keys ?? Object.keys(cache);\n    if (!Array.isArray(keys)) keys = [\n        keys\n    ];\n    for (const cacheKey of keys){\n        clearInterval(cache[cacheKey]?.refresh);\n        cache[cacheKey] = undefined;\n    }\n};\nexport const jsonSafeParse = (text, reviver)=>{\n    if (typeof text !== 'string') return text;\n    const firstChar = text[0];\n    if (firstChar !== '{' && firstChar !== '[' && firstChar !== '\"') return text;\n    try {\n        return JSON.parse(text, reviver);\n    } catch (e) {}\n    return text;\n};\nexport const jsonSafeStringify = (value, replacer, space)=>{\n    try {\n        return JSON.stringify(value, replacer, space);\n    } catch (e) {}\n    return value;\n};\nexport const normalizeHttpResponse = (request)=>{\n    let { response  } = request;\n    if (typeof response === 'undefined') {\n        response = {};\n    } else if (typeof response?.statusCode === 'undefined' && typeof response?.body === 'undefined' && typeof response?.headers === 'undefined') {\n        response = {\n            body: response\n        };\n    }\n    (_response = response).headers ?? (_response.headers = {});\n    request.response = response;\n    return response;\n};\nconst createErrorRegexp = /[^a-zA-Z]/g;\nexport class HttpError extends Error {\n    constructor(code, message, options = {}){\n        if (message && typeof message !== 'string') {\n            options = message;\n            message = undefined;\n        }\n        message ?? (message = httpErrorCodes[code]);\n        super(message);\n        this.cause = options.cause;\n        const name = httpErrorCodes[code].replace(createErrorRegexp, '');\n        this.name = name.substr(-5) !== 'Error' ? name + 'Error' : name;\n        this.status = this.statusCode = code;\n        this.expose = options.expose ?? code < 500;\n    }\n}\nexport const createError = (code, message, properties = {})=>{\n    return new HttpError(code, message, properties);\n};\nconst httpErrorCodes = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    103: 'Early Hints',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    208: 'Already Reported',\n    226: 'IM Used',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    306: '(Unused)',\n    307: 'Temporary Redirect',\n    308: 'Permanent Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Payload Too Large',\n    414: 'URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Range Not Satisfiable',\n    417: 'Expectation Failed',\n    418: \"I'm a teapot\",\n    421: 'Misdirected Request',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    425: 'Unordered Collection',\n    426: 'Upgrade Required',\n    428: 'Precondition Required',\n    429: 'Too Many Requests',\n    431: 'Request Header Fields Too Large',\n    451: 'Unavailable For Legal Reasons',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    506: 'Variant Also Negotiates',\n    507: 'Insufficient Storage',\n    508: 'Loop Detected',\n    509: 'Bandwidth Limit Exceeded',\n    510: 'Not Extended',\n    511: 'Network Authentication Required'\n};\n\n\n//# sourceMappingURL=index.js.map", "import { createError } from '@middy/util';\nconst mimePattern = /^application\\/(.+\\+)?json(;.*)?$/;\nconst defaults = {\n    reviver: undefined\n};\nconst httpJsonBodyParserMiddleware = (opts = {})=>{\n    const { reviver  } = {\n        ...defaults,\n        ...opts\n    };\n    const httpJsonBodyParserMiddlewareBefore = async (request)=>{\n        const { headers , body  } = request.event;\n        const contentType = headers['Content-Type'] ?? headers['content-type'];\n        if (!mimePattern.test(contentType)) return;\n        try {\n            const data = request.event.isBase64Encoded ? Buffer.from(body, 'base64').toString() : body;\n            request.event.rawBody = body;\n            request.event.body = JSON.parse(data, reviver);\n        } catch (cause) {\n            const error = createError(422, 'Invalid or malformed JSON was provided');\n            error.cause = cause;\n            throw error;\n        }\n    };\n    return {\n        before: httpJsonBodyParserMiddlewareBefore\n    };\n};\nexport default httpJsonBodyParserMiddleware;\n\n\n//# sourceMappingURL=index.js.map", "import middy from '@middy/core';\nimport middyJsonBodyParser from '@middy/http-json-body-parser';\n\nexport const middyfy = (handler) => middy(handler).use(middyJsonBodyParser());\n"],
  "mappings": "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",
  "names": ["middy", "_a"]
}
